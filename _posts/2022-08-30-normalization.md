---
title: "[SQL] 정규화(Normalization)"
categories:
  - SQL
tags:
  - SQL
  - 정규화
  - Normalization
toc: true
toc_sticky: true
toc_label: "목차"
---

데이터 모델링에서 정규화는 가장 기초적이지만 필수적으로 이루어져야하는 작업이다. 성능을 위해 반정규화를 하기도 하지만, 그 이전에 정규화가 왜 필요한지를 반드시 알아야 한다. 다음 몇가지 사례를 통해 정규화가 무엇인지와 그 필요성을 알아보자.

# 정규화란?
---
관계형 데이터베이스의 설계에서 중복을 최소화하게 데이터를 구조화하는 프로세스를 정규화라고 한다. 데이터베이스 정규화의 목표는 이상이 있는 관계를 재구성하여 작고 잘 조직된 관계를 생성하는 것에 있다. 일반적으로 정규화란 크고, 제대로 조직되지 않은 테이블들과 관계들을 작고 잘 조직된 테이블과 관계들로 나누는 것을 포함한다.

<br>

# 정규화의 목적
---
- 데이터베이스의 변경시 이상 현상 제거
  >테이블 수정(갱신, 삽입, 삭제)시, 원치 않던 부작용이 발생할 수 있다. 이 부작용은 충분히 정규화되지 않은 테이블에서 발생하며, 때문에 충분히 정규화 되지 않은 테이블은 갱신이상, 삽입이상, 삭제이상 문제를 가지고 있다. 그래서 해당 문제들을 해소하기 위해서는 정규화가 필요하다.
- 데이터베이스 구조 확장시 재 디자인 최소화
  >정규화된 데이터베이스 구조에서는 새로운 데이터 형의 추가로 인한 확장시, 그 구조를 변경하지 않아도 되거나 일부만 변경해도 되는 경우가 있다. 이는 이 데이터베이스와 연동된 응용 프로그램에 최소한의 영향만을 주며, 응용 프로그램의 생명을 연장시킨다.
- 사용자에게 데이터 모델을 더욱 의미있게 제공
  >정규화된 테이블들과 정규화된 테이블들간의 관계들은 현실세계에서의 개념들과 그들간의 관계들을 반영한다. 즉 데이터 모델을 사용자에게 더욱 의미있게 한다.
- 다양한 질의 지원
  >정규화된 테이블은 일반적인 목적의 질의에 적합하다. 이는 테이블에 대하여 세부사항이 예측되지 않은 장래의 질의를 포함한 어떠한 질의도 지원한다는 의미이다. 반대로 정규화되지 않은 테이블은 (향후 발생할 수 있는) 어떤 질의들은 지원하지 않을 수 있다.

<br>

# 정규화의 장단점
## 장점
- 데이터베이스 변경 시 이상 현상(Anomaly)을 제거할 수 있다.
- 정규화된 데이터베이스 구조에서는 새로운 데이터 형의 추가로 인한 확장 시, 그 구조를 변경하지 않아도 되거나 일부만 변경해도 된다.
- 데이터베이스와 연동된 응용 프로그램에 최소한의 영향만을 미치게 되어 응용프로그램의 생명을 연장시킨다.

## 단점
- 릴레이션의 분해로 인해 릴레이션 간의 JOIN연산이 많아진다.
- 질의에 대한 응답시간이 느려질 수도 있다. 데이터의 중복 속성을 제거하고 결정자에 의해 동일한 의미의 일반 속성이 하나의 테이블로 집약되므로 한 테이블의 데이터 용량이 최소화되는 효과가 있다. 
- 따라서 데이터를 처리할 때 속도가 빨라질 수도 있고 느려질 수도 있다.
- 만약 조인이 많이 발생하여 성능저하가 나타나면 반정규화(De-normalization)를 적용할 수도 있다.

<br>

# 정규형
정규형은 정규화된 결과를 말한다. 정규형은 기본 정규형과 고급 정규형으로 나뉘며, 상세한 내용은 아래와 같다.
## 기본 정규형
기본 정규형에는 제 1 정규형(1NF), 제 2 정규형(2NF), 제 3 정규형(3NF), 보이스/코드 정규형(BCNF)이 있다.
- 제 1 정규형(1NF)
  >릴레이션에 속한 모든 속성의 도메인이 더 이상 분해되지 않는 원자값으로만 구성된 정규형이다.
  >
  >![제 1 정규형의 예](/blog/assets/img/posts/20220830/1NF.png "제 1 정규형의 예"){: width="100%"}
  ><div style="color: gray; text-align: center; margin-bottom: 30px;">제 1 정규형의 예</div>
- 제 2 정규형(2NF)
  >릴레이션이 제1정규형에 속하고, 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속되면 제2정규형에 속한다.
  >제1정규형에 속하는 릴레이션이 제2정규형을 만족하려면, 부분 함수 종속을 제거하고 모든 속성이 기본키에 완전 함수 종속되도록 릴레이션을 분해하는 정규화 과정을 거쳐야 한다.
  >
  >![제 2 정규형의 예](/blog/assets/img/posts/20220830/2NF.png "제 2 정규형의 예"){: width="100%"}
  ><div style="color: gray; text-align: center; margin-bottom: 30px;">제 2 정규형의 예</div>
  >__알고가기__
  >- 완전 함수 종속  
  >: 어떤 속성이 기본키에 대해 완전히 종속일 때
  >- 부분 함수 종속  
  >: 어떤 속성이 기본키가 아닌 다른 속성에 종속되거나, 기본키가 여러 속성으로 구성되어 있을경우 기본키를 구성하는 속성 중 일부만 종속될 때
- 제 3 정규형(3NF)
  >릴레이션이 제2정규형에 속하고, 기본키가 아닌 모든 속성이 기본키에 이행적 함수 종속이 되지 않으면 제3정규형에 속한다.
  >
  >![제 3 정규형의 예](/blog/assets/img/posts/20220830/3NF.png "제 3 정규형의 예"){: width="100%"}
  ><div style="color: gray; text-align: center; margin-bottom: 30px;">제 3 정규형의 예</div>
  >__알고가기__
  >- 이행적 함수 종속  
  >: - A → B , B → C 인 경우 A → C 가 성립될 때
  >: - 즉, A를 알면 B를 알고 그를 통해 C를 알 수 있는 경우를 의미
- 보이스/코드 정규형(BCNF)
  >릴레이션의 함수 종속 관계에서 모든 결정자가 후보키이면 BCNF에 속한다.  
  >
  >하나의 릴레이션에 여러개의 후보키가 존재할 수도 있는데, 이런 경우는 제3정규형까지 모두 만족하더라도 이상 현상이 발생할 수 있다. 이러한 이상현상을 해결하기 위해 제3정규형보다 좀 더 
  >엄격한 제약조건을 제시한 것이 BCNF이다.
  >
  >![보이스/코드 정규형의 예](/blog/assets/img/posts/20220830/BCNF.png "보이스/코드 정규형의 예"){: width="100%"}
  ><div style="color: gray; text-align: center; margin-bottom: 30px;">보이스/코드 정규형의 예</div>

## 고급 정규형
기본 정규형에는 제 4 정규형(4NF), 제 5 정규형(5NF)이 있다.
- 제 4 정규형(4NF)
  >릴레이션이 BCNF를 만족하면서 다치 종속(MVD: Multi Valued Dependency)을 제거하면 제 4 정규형에 속한다.

<br>

# 반정규화란?
---
반정규화는 정규화를 반대로 하는 것으로 역정규화라고도 한다. 정규화는 데이터의 중복을 최소화했다면, 반정규화는 성능을 위해 데이터 중복을 허용하는 것이다. 그러므로 성능이 문제될 때 주로 반정규화에 대해 논의하게 된다. 하지만 반정규화가 항상 성능을 향상시키는가? 아니다. 조회성능을 향상시킬 수 있을지 모르겠으나 그로인한 입력·수정·삭제 성능은 저하될 수 있다. 이 부분을 염두해 두고 반정규화를 진행해야 한다.

<br>

# 반정규화가 성능에 미치는 영향
- 반정규화를 적용한 모델에서 성능이 향상 될 수 경우
  >

---

읽어주셔서 감사합니다. 😊

__Reference__  
SQL 전문가 가이드 - Kdata 한국데이터산업진흥원  
[정규화란? - Tistory](https://code-lab1.tistory.com/48)  
[데이터베이스 정규화 - wikipedia](https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_%EC%A0%95%EA%B7%9C%ED%99%94)  
[데이터베이스 정규화 - Tistory](https://hongcoding.tistory.com/147)  